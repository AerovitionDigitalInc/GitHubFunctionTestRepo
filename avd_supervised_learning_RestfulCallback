/*
Created by :
Aerovition Digital Inc.,An Aerovition Company
International Copyright law @2016.
Date: 7/8/2016
Author: Shaw Rahman

Research Domain: 
1. Applied Artificial Intelligence, 
2. Machime Learning.
3. Two tree SVM
4. supervised learning
5. Model Driven system Of systems MDA_LSSI_SOS
6. Recommendations systems in BigData

Wriiten in Angula Js (MEAN)/ any JS is ('use strict')applicable.

-----------------------------------------------------------------------------------------
The following object oriented callback,"overloads 
as OO function any data structure as domain onjects" 
[for applications of graph theory or , (Any)Tree(s)], 
and provides a learner, in supervised learning, a mechanism,
to "classfy", using  algorithms(options:Machine Learning:Classfication;
Support Vector Machine, SNM), to build  Restful API / Callback or to apply RestfulAPI in 
A Recommnedation system, in BigData.

Prerequisite:

Business Transformation
__________________________________________________________________________________________
Input and output across Business domains or in casual chain (where beginning and end)are  
defined observations. Latent variables ( product undefined, produced by  another domain , 
which are input to a subsequent domain in interconnected LOB ,  in casual chain, will 
result in a non supervised learning. Cross domain observations  / data quality or error 
can be resolved by introduction  of a second tree for  the first dynamically, and 3rd for 
the 2nd tree,  using two tree SVM for any "classifier /or non classifier (value) regression 
analysis ,in Product definition/Definition of Product/System Specification or Restful API. 
A hierarchical geometric symmetric model  can be constructed dynamically if the latent 
variables,  the highest level of nodes are undefined to bridge gaps (or via  introduction 
of business  generic patterns) , for cross domain /causal chains' "casual gaps", to bridge 
up gaps, in A Complex System Model (MDA_LSSI_SOS), where the observations' input &  output 
domain objects  form a symmetric hierarchical structure.    ( Federated solution For Multi 
Verticals: Healthcare, Medicine, Banking, Transportation, Education Research, Aerospace & 
Defense, Government Administrative Departments : Interconnected Network Operations 
Management in Casual Chains)

Action chaining at point of concern, using such Restful APIs  by 
provisioning  (JSR311) can optimally integrate Federated Cloud 
Platforms across business theatres, within A single function 
/ API call or callback.
                                    ---  Chief Engineer. Architect. 

-------------------------------------------------------------------------------------------

*/
var test_element;

var find_sample = function (test_element){
    try{
        a_sed_function1 : function(){
        if(test_element === "object" && test_element =! null && test_element === function )
            return test_element;
        }
    },
    Catch(err){
        a_sed_function2 : function(){
            return throw exception ( "test" + err);
    },
    return{
           a_sed_function1:a_sed_function1;
          //or a sec. one.  a_sed_function1:a_sed_function2;
    };


};

--------------------------------------------------------------------------------------------

var Node(
    previosu;
    next;
    data;
);
Node node()(
    this.previous =null;
    this.next= null;
    this.data =[];
};
DList var(
    head;
    tail;
    lenght;);

DList DList(){
    this.head =nul;
    this.tail=null;
    this.lenght=0;
};
//var Node nodeObjectFunction = node_object_collections(Node, SinglyList, Dlist, callback)[{
//insert
//current node is always the node to deal with.
Node insertNode = insert_begin_function(Node currentNode){
//insert at the begining:
    DList.head.previous = currentNode.next;
    currentNode.previous = null;
    Dlist.this.length = ++Dlist.this.length;
    return currentNode;
};
//insert at the end:
Node insertNode = insert_end_function(Node currentNode){
    DList.tail.next = currentNode.previous;
    currentNode.previous = Dlist.tail.head;
    Dlist.this.length = ++Dlist.this.length;
    return currentNode;
};
//insert in the middle:
Node insertNode = insert_middle_function(Node currentNode){
    var position;
    if (Dlist.this.length > position) //position insert found;I beleve it
    {
        Dlist.head.next = currentNode.previous;
        Dlist.tail.previous = currentNode.next;
        var position_found = position;
        console.log("display" + DList.currentNode.data);
    }
    return currentNode;
}
Node searchNode = search_position_function(Node currentNode)  {
//position locatiion:
var position;
    if (Dlist.this.length > position){
        var position_searched_found = position;
        Dlist.length =  position_searched_found; //stop at this posiotn;
        Dlist.head.next = currentNode.previous;
        currentNode.next= Dlist.tail.head;
        console.log("display" + DList.currentNode.data);
}
},
Node toDeleteNode = delete_node_function(Node currentNode){ 
// if a reference node is passed or 
//delete 11 th note positon = 10(str at 0)
//delete in the middle:

var position;
    if (Dlist.this.length > position){
        var position_searched_found = position;
        Node beforenodeToDelete = currentNode.previous;
        Node afternodeToDelete = currentNode.next;
        Node deleteNode = currentNode;
        //then connect the before  and after nodes
        beforenodeToDelete= afternodeTodelete.previous;
        afternodeToDelete = beforenodeToDelete.next;
        deleteNode.data = null;
        delete Node.previous = null;
        deleteNode.next = null;

        return deleteNode;
},
 if (Dlist.this.length < position){  //delete at the end.
        var position_searched_found = position;

        Dlist.tail.next = currentNode.previous;
        curretnNode.next = null;
        Node deleteNode=currentNode;
        deleteNode.data = null;
        delete Node.previous = null;
        deleteNode.next=null; //linked list
        },

if (position === 0){  //delete at the begining.
        var position_searched_found = position;
        currentNode.previous = null;
        Dlist.head.previous=currentNode.next;
        Node deleteNode=currentNode;
        deleteNode.data = null;
        delete Node.previous =null;
        deleteNode.next=null;
        }},

var Btree(
         Node LeftChild;
         Node RightChild;
         var count_child_left;
         var count_child_right;
         Btree left_node_ptr;
         Btree right_node_ptr;
  ),
Node LeftChild{

 },
NodeRightChild{

},

//constructors;

Btree btree(){
//properties initialization;
},
Node LeftChild(){
//two different properties initialization;
},

Node RightChild(){
//proprerties initialization;
},


/*
* Singely linkeindlist
*/

var SinglyList(
    var data; //1,2, 3 data fileds.
    var next_link;
),
SinglyList singlylist(){
    data = [];
    next_link=null; //first node.

},
//Node currentNode;
//insert: currentNode.next_link= singleyList;
//SingelyList = Singelylist.next //advances.

//insert at the end
SingelyList.next = currentNode;
//if middle : what data location, currentNode.data <> SingleyList.data :test then insert;
//or search anywhere in the list.

//Delete:
//if middle : what data location, currentNode.data <> SingleyList.data :test then insert;

currentNode.next = null;
Node deleteNode;
deleteNode.data = currentNode.data
deleteNode = currentNode;
SingelyList =- SinglyList.next;

//if delete at the end:

currentNode.next=null;
SingelyList.next=currentNode;
deleteNode=currentNode;
deleteNode.data=null;
deleteNode.next=null;

//delete at the front.(can be , is a data match or if not logic.
currentNode.next=null;
currentNode.data = null;
SingelyList =- SinglyList.next;
//review***
}
callback(currentNode, Singlylist, DblyLsit);  //Overload OO callbacks ...with any domain object as parameter.
]
